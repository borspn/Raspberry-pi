package main

import (
	"log"
	"os"
	"syscall"
	"unsafe"
)

var (
	//spiPort     spi.Conn
	//csLine      *gpiocdev.Line
	spiFile     *os.File
	csValueFile *os.File
)

// Global constants
const (
	defaultMeasDelaySec = 1
	defaultCSGPIO       = 25
	defaultSPIPath      = "spidev0.0"
	defaultSPIChipName  = "gpiochip0"
	speedOfSoundWater   = 1480.0
	lenOfSens           = 0.06456
	crossArea           = 0.000501653
	kFact               = 1.008
	vfrConstant         = 15850.32
	hsCkolck            = 4e6
	tRef                = 1.0 / hsCkolck
)

// Adresses, opcodes and masks constants
const (
	tofHitNOMask    uint32 = 0x00001F00
	fesCLRMask      uint32 = 1 << 2
	efCLRMask       uint32 = 1 << 1
	ifCLRMask       uint32 = 1 << 0
	usAMUPDMask     uint32 = 1 << 8
	rcBMREQ         byte   = 0x88
	rcMCTOFF        byte   = 0x8A
	rcRAAWRRAM      byte   = 0x5A
	rcRAARDRAM      byte   = 0x7A
	shrTOFRate      byte   = 0xD0
	shrUSMRLSDLYU   byte   = 0xD1
	shrUSMRLSDLYD   byte   = 0xD2
	shrZCDFHLU      byte   = 0xDA
	shrZCDFHLD      byte   = 0xDB
	shrEXC          byte   = 0xDD
	rcMCTON         byte   = 0x8B
	rcIFCLR         byte   = 0x8D
	rcBMRLS         byte   = 0x87
	fdbUSAMCVH      byte   = 0x83
	fdbUSAMCVL      byte   = 0x87
	fdbUSAMU        byte   = 0x82
	fdbUSAMD        byte   = 0x86
	fdbUSTOFADDALLU byte   = 0x80
	fdbUSTOFADDALLD byte   = 0x84
	fdbUSPWU        byte   = 0x81
	fdbUSPWD        byte   = 0x85
	srrERRFLAG      byte   = 0xE1
	shrFHLU         byte   = 0xDA
	shrFHLD         byte   = 0xDB
)

// Global variables
var (
	myErrorCounter     uint32  = 0
	myNewConfiguration uint8   = 1
	myNewFHL           uint8   = 0
	myNewFHLmV         float32 = 0
	mySetFHLmV         float32 = 0
	myTOFSumAvgUP      float32
	myTOFSumAvgDOWN    float32
	myDiffTOFSumAvg    float32
	myTOFSumAvgUPNs    float32
	myTOFSumAvgDOWNNs  float32
	myDiffTOFSumAvgPs  float32
	myChipInitialized  uint8 = 0
	tofHitNO           uint32
	srrERRFLAGContent  uint32
)

// This data represents firmware configuration of AS6031 chip
var fwc = []byte{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA1, 0xF1, 0x11, 0x01, 0xF2, 0xDC, 0x61, 0x1B, 0x64, 0x16, 0xF2, 0xDC, 0x61, 0x13, 0x64, 0x31,
	0xF2, 0xDC, 0x61, 0x23, 0x64, 0x2E, 0xF2, 0xDC, 0x61, 0x2B, 0x64, 0x76, 0xC9, 0x01, 0x1D, 0xF2,
	0xE2, 0x61, 0x37, 0xC9, 0x01, 0x1D, 0xB8, 0x77, 0xF2, 0x80, 0x2D, 0xF2, 0x84, 0x37, 0x7D, 0xCA,
	0x00, 0x66, 0xF2, 0xC1, 0x61, 0x43, 0xCA, 0xF9, 0x11, 0xF2, 0xDD, 0xF1, 0xAB, 0xC9, 0x01, 0x1D,
	0xC9, 0x01, 0x1D, 0xC9, 0x01, 0x1D, 0xF2, 0x80, 0x77, 0xF2, 0x84, 0x7B, 0x88, 0x73, 0xCB, 0x74,
	0xF2, 0xA5, 0x7D, 0x76, 0x88, 0x73, 0xCB, 0x74, 0xF2, 0xA6, 0x7D, 0xF2, 0xA6, 0x73, 0xF2, 0xA5,
	0x33, 0x87, 0x7C, 0xF3, 0x03, 0x77, 0x34, 0x71, 0xF3, 0x05, 0x0F, 0x4B, 0x13, 0x5D, 0x73, 0xF3,
	0x04, 0x13, 0x4D, 0x73, 0xF2, 0x5E, 0x77, 0xCB, 0x54, 0xCA, 0xFD, 0x67, 0x75, 0x3B, 0x9A, 0xCA,
	0x00, 0xCB, 0x54, 0xCA, 0xFD, 0x67, 0xF3, 0x02, 0x77, 0xCB, 0x54, 0xCA, 0xFD, 0x67, 0x82, 0x7C,
	0xCF, 0xF3, 0x67, 0x73, 0xF2, 0xD1, 0x7C, 0xF2, 0xD2, 0x7C, 0xF2, 0x5F, 0x7F, 0x00, 0x3D, 0x09,
	0x00, 0xF2, 0x5E, 0x7F, 0x00, 0x00, 0x04, 0x31, 0xF2, 0xC5, 0x62, 0x03, 0xF2, 0x5F, 0xD3, 0xF2,
	0xC5, 0x62, 0x03, 0xF2, 0x5E, 0xC3, 0xF2, 0xCA, 0x73, 0xCB, 0x80, 0x00, 0x00, 0x1F, 0x00, 0xCE,
	0x70, 0x88, 0x7C, 0xF2, 0xC6, 0x73, 0xCB, 0x80, 0x00, 0x00, 0x1F, 0xFF, 0x09, 0xCB, 0xA5, 0x00,
	0x00, 0x00, 0x1F, 0xF2, 0xD0, 0x7B, 0xCB, 0x86, 0xCB, 0x54, 0xCE, 0x58, 0xF2, 0xE3, 0x63, 0x47,
	0x75, 0x00, 0x01, 0x06, 0x24, 0xCB, 0x54, 0xCA, 0xFD, 0x67, 0xF2, 0x9E, 0x7C, 0xF3, 0x5B, 0x73,
	0xF3, 0x5C, 0x77, 0xF2, 0x9E, 0x7B, 0xCA, 0xF3, 0x1C, 0x8A, 0x7C, 0x64, 0x01, 0xF2, 0xDC, 0x0B,
	0xCD,
}

func InitSPI(chipName string, csGPIO int, spiDev string) {
	// 1) Open SPI device
	devPath := "/dev/" + spiDev
	f, err := os.OpenFile(devPath, os.O_RDWR, 0)
	if err != nil {
		log.Fatalf("Failed to open SPI device %s: %v", devPath, err)
	}
	spiFile = f

	const (
		spiIOCWrMode        = 0x40016b01 // _IOW('k', 1, __u8)
		spiIOCWrBitsPerWord = 0x40016b03 // _IOW('k', 3, __u8)
		spiIOCWrMaxSpeedHz  = 0x40046b04 // _IOW('k', 4, __u32)
	)
	// These must be vars so we can take their address:
	var (
		mode1       = uint8(1)
		bits8       = uint8(8)
		speed500kHz = uint32(500000)
	)

	// 2a) Set SPI mode to Mode1
	if _, _, errno := syscall.Syscall(syscall.SYS_IOCTL, f.Fd(),
		spiIOCWrMode, uintptr(unsafe.Pointer(&mode1))); errno != 0 {
		log.Fatalf("Failed to set SPI mode: %v", errno)
	}
	// 2b) Set bits-per-word = 8
	if _, _, errno := syscall.Syscall(syscall.SYS_IOCTL, f.Fd(),
		spiIOCWrBitsPerWord, uintptr(unsafe.Pointer(&bits8))); errno != 0 {
		log.Fatalf("Failed to set SPI bits-per-word: %v", errno)
	}
	// 2c) Set max-speed = 500 kHz
	if _, _, errno := syscall.Syscall(syscall.SYS_IOCTL, f.Fd(),
		spiIOCWrMaxSpeedHz, uintptr(unsafe.Pointer(&speed500kHz))); errno != 0 {
		log.Fatalf("Failed to set SPI max speed: %v", errno)
	}
	// 3) Export CS GPIO via sysfs (if not already)
	// gpioPath := fmt.Sprintf("/sys/class/gpio/gpio%d", csGPIO)
	// if _, err := os.Stat(gpioPath); os.IsNotExist(err) {
	// 	if err := os.WriteFile("/sys/class/gpio/export",
	// 		[]byte(fmt.Sprintf("%d", csGPIO)), 0644); err != nil {
	// 		log.Fatalf("Failed to export GPIO %d: %v", csGPIO, err)
	// 	}
	// }
	// 4) Configure direction = out
	if err := os.WriteFile(gpioPath+"/direction",
		[]byte("out"), 0644); err != nil {
		log.Fatalf("Failed to set GPIO direction: %v", err)
	}
	// 5) Open the value file for later SetCS calls
	vf, err := os.OpenFile(gpioPath+"/value", os.O_WRONLY, 0)
	if err != nil {
		log.Fatalf("Failed to open GPIO value file: %v", err)
	}
	csValueFile = vf

	// 6) Drive CS high (inactive)
	if _, err := csValueFile.WriteString("1"); err != nil {
		log.Fatalf("Failed to set CS idle state: %v", err)
	}

	log.Printf("SPI initialized: device=%s, cs_gpio=%d\n", devPath, csGPIO)
	// …rest of function unchanged…
}
